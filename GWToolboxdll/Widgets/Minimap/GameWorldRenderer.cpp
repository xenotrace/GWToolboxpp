#include "stdafx.h"

#include <GWCA/Context/MapContext.h>
#include <GWCA/GameContainers/GamePos.h>
#include <GWCA/GameEntities/Camera.h>
#include <GWCA/GameEntities/Pathing.h>
#include <GWCA/Managers/CameraMgr.h>
#include <GWCA/Managers/MapMgr.h>
#include <GWCA/Managers/RenderMgr.h>

#include <Defines.h>
#include <Widgets/Minimap/GameWorldRenderer.h>
#include <Widgets/Minimap/Minimap.h>

// Note: these two files are autogenerated by CMake!
#include "Shaders/game_world_renderer_ps.h"
#include "Shaders/game_world_renderer_vs.h"

namespace {
    unsigned lerp_steps_per_line = 10;
    float render_max_distance = 5000.f;
    float fog_factor = 0.5f;
    bool need_sync_markers = true;
    bool need_configure_pipeline = true;
    std::vector<std::unique_ptr<GameWorldRenderer::GenericPolyRenderable>> renderables;
    std::mutex renderables_mutex{};
    IDirect3DVertexShader9* vshader = nullptr;
    IDirect3DPixelShader9* pshader = nullptr;
    IDirect3DVertexDeclaration9* vertex_declaration = nullptr;

    constexpr GW::Vec2f lerp(const GW::Vec2f& a, const GW::Vec2f& b, const float t)
    {
        return a * t + b * (1.f - t);
    }

    constexpr auto ALTITUDE_UNKNOWN = std::numeric_limits<float>::max();

    std::vector<GW::Vec2f> circular_points_from_marker(const float pos_x, const float pos_y, const float size)
    {
        std::vector<GW::Vec2f> points{};
        constexpr float pi = DirectX::XM_PI;
        constexpr size_t num_points_per_circle = 48;
        constexpr auto slice = 2.0f * pi / static_cast<float>(num_points_per_circle);
        for (auto i = 0u; i < num_points_per_circle; i++) {
            const auto angle = slice * static_cast<float>(i);
            points.push_back(GW::Vec2f{pos_x + size * std::cos(angle), pos_y + size * std::sin(angle)});
        }
        points.push_back(points.at(0)); // to complete the line list
        return points;
    }
} // namespace

GameWorldRenderer::GenericPolyRenderable::GenericPolyRenderable(
    IDirect3DDevice9* device,
    const GW::Constants::MapID map_id,
    const std::vector<GW::Vec2f>& points,
    const unsigned int col,
    const bool filled)
    : map_id(map_id)
    , col(col)
    , points(points)
    , filled(filled)
{
    if (filled && points.size() >= 3) {
        // (filling doesn't make sense if there is not at least enough points for one triangle)
        std::vector<GW::Vec2f> lerp_points{};
        for (size_t i = 0; i < points.size(); i++) {
            const GW::Vec2f& pt = points.at(i);
            if (!lerp_points.empty() && lerp_steps_per_line > 0) {
                for (auto j = 1u; j < lerp_steps_per_line; j++) {
                    const float div = static_cast<float>(j) / static_cast<float>(lerp_steps_per_line);
                    GW::Vec2f split = lerp(points[i], points[i - 1], div);
                    lerp_points.push_back(split);
                }
            }
            lerp_points.push_back(pt);
        }
        const auto poly = std::vector{{lerp_points}};
        const std::vector<unsigned> indices = mapbox::earcut<unsigned>(poly);
        for (size_t i = 0; i < indices.size(); i++) {
            const auto& pt = lerp_points.at(indices.at(i));
            vertices.push_back(D3DVertex{pt.x, pt.y, ALTITUDE_UNKNOWN, col});
        }
    }
    else {
        for (size_t i = 0; i < points.size(); i++) {
            const GW::Vec2f& pt = points.at(i);
            if (!vertices.empty() && lerp_steps_per_line > 0) {
                for (auto j = 1u; j < lerp_steps_per_line; j++) {
                    const auto div = static_cast<float>(j) / static_cast<float>(lerp_steps_per_line);
                    const auto split = lerp(points[i], points[i - 1], div);
                    vertices.push_back(D3DVertex{split.x, split.y, ALTITUDE_UNKNOWN, col});
                }
            }
            vertices.push_back(D3DVertex{pt.x, pt.y, ALTITUDE_UNKNOWN, col});
        }
    }

    device->CreateVertexBuffer(vertices.size() * sizeof(D3DVertex), D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_MANAGED, &vb, nullptr);
}

GameWorldRenderer::GenericPolyRenderable::~GenericPolyRenderable()
{
    if (vb != nullptr) {
        vb->Release();
    }
}

void GameWorldRenderer::GenericPolyRenderable::Draw(IDirect3DDevice9* device)
{
    // draw this specific renderable
    if (device->SetStreamSource(0, vb, 0, sizeof(D3DVertex)) != D3D_OK) {
        // a safe failure mode
        return;
    }
    // update altitudes if not done already
    if (!all_altitudes_queried) {
        // altitudes (Z value) for each vertex can't be known until we are in the correct map,
        // so these are dynamically computed, one-time.
        float altitude = ALTITUDE_UNKNOWN;

        // in order to properly query altitudes, we have to use the pathing map
        // to determine the number of Z planes in the current map.
        const GW::PathingMapArray* pathing_map = GW::Map::GetPathingMap();
        if (pathing_map != nullptr) {
            const size_t pmap_size = pathing_map->size();
            if (pmap_size > 0) {
                for (size_t i = 0; i < vertices.size(); i++) {
                    // until we have a better solution, all Z planes will be queried per vertex
                    // to avoid a significant delay in the render thread, query one plane per frame
                    // until all have been queried. this might result in some renderables shifting
                    // not appearing for a while on first map load, but IMO is better than stalling.
                    // It seems to take, even in most extreme cases, less time than it takes for agents
                    // to appear.
                    GW::Map::QueryAltitude({vertices[i].x, vertices[i].y, cur_altitude}, 0.1f, altitude);
                    if (altitude < vertices[i].z) {
                        // recall that the Up camera component is inverted
                        vertices[i].z = altitude;
                    }
                }
                if (cur_altitude++ == pmap_size - 1) {
                    all_altitudes_queried = true;
                    // commit the completed vertices to vram
                    void* mem_loc = nullptr;
                    // map the vertex buffer memory and write vertices to it.
                    if (vb->Lock(0, vertices.size() * sizeof(D3DVertex), &mem_loc, D3DLOCK_DISCARD) == S_OK && mem_loc != nullptr) {
                        // this should avoid an invalid memcpy, if locking fails for some reason
                        memcpy(mem_loc, vertices.data(), vertices.size() * sizeof(D3DVertex));
                        vb->Unlock();
                    }
                }
            }
        }
    }
    // copy the vertex buffer to the back buffer
    filled ? device->DrawPrimitive(D3DPT_TRIANGLELIST, 0, vertices.size() / 3) : device->DrawPrimitive(D3DPT_LINESTRIP, 0, vertices.size() - 1);
}

bool GameWorldRenderer::SetD3DTransform(IDirect3DDevice9* device)
{
    // set up directX standard view/proj matrices according to those used to render the game world
    if (device == nullptr) {
        return false;
    }

    constexpr auto vertex_shader_view_matrix_offset = 0u;
    constexpr auto vertex_shader_proj_matrix_offset = 4u;

    // compute view matrix:
    DirectX::XMFLOAT4X4A mat_view{};
    const auto cam = GW::CameraMgr::GetCamera();
    const DirectX::XMFLOAT3 eye_pos = {cam->position.x, cam->position.y, cam->position.z};
    const DirectX::XMFLOAT3 player_pos = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z};
    constexpr DirectX::XMFLOAT3 up = {0.0f, 0.0f, -1.0f};
    XMStoreFloat4x4A(
        &mat_view,
        XMMatrixTranspose(
            DirectX::XMMatrixLookAtLH(XMLoadFloat3(&eye_pos), XMLoadFloat3(&player_pos), XMLoadFloat3(&up))
        )
    );
    if (device->SetVertexShaderConstantF(vertex_shader_view_matrix_offset, reinterpret_cast<const float*>(&mat_view), 4) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetVertexShaderConstantF(view), aborting render.");
        return false;
    }

    // compute projection matrix:
    DirectX::XMFLOAT4X4A mat_proj{};
    const auto fov = GW::Render::GetFieldOfView();
    const auto aspect_ratio = static_cast<float>(GW::Render::GetViewportWidth()) / static_cast<float>(GW::Render::GetViewportHeight());

    XMStoreFloat4x4A(
        &mat_proj,
        XMMatrixTranspose(
            DirectX::XMMatrixPerspectiveFovLH(fov, aspect_ratio, 0.1f, 100000.0f)
        )
    );
    if (device->SetVertexShaderConstantF(vertex_shader_proj_matrix_offset, reinterpret_cast<const float*>(&mat_proj), 4) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetVertexShaderConstantF(projection), aborting render.");
        return false;
    }

    return true;
}

void GameWorldRenderer::Render(IDirect3DDevice9* device)
{
    if (need_sync_markers) {
        // marker synchronisation is done when needed on the render thread, as it requires access
        // to the directX device for creating vertex buffers.
        SyncAllMarkers(device);
    }
    if (renderables.empty()) {
        // if nothing ticked "Draw On Terrain", don't waste performance
        return;
    }
    if (need_configure_pipeline) {
        if (!ConfigureProgrammablePipeline(device)) {
            return;
        }
    }

    if (!Minimap::ShouldMarkersDrawOnMap()) {
        return;
    }

    if (vshader == nullptr || device->SetVertexShader(vshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetVertexShader, aborting render.");
        return;
    }
    if (pshader == nullptr || device->SetPixelShader(pshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetPixelShader, aborting render.");
        return;
    }
    if (device->SetVertexDeclaration(vertex_declaration) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to SetVertexShader declaration, aborting render.");
        return;
    }

    // backup original immediate state and transforms:
    DWORD old_D3DRS_SCISSORTESTENABLE = 0;
    DWORD old_D3DRS_STENCILENABLE = 0;
    device->GetRenderState(D3DRS_SCISSORTESTENABLE, &old_D3DRS_SCISSORTESTENABLE);
    device->GetRenderState(D3DRS_STENCILENABLE, &old_D3DRS_STENCILENABLE);

    // no scissor test / stencil (used by minimap)
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, 0u);
    device->SetRenderState(D3DRS_STENCILENABLE, 0u);

    if (SetD3DTransform(device)) {
        const GW::Camera* cam = GW::CameraMgr::GetCamera();
        // set Pixel Shader constants. they are always expressed as Float4 here:
        // first is the player's position

        constexpr auto pixel_shader_cur_pos_offset = 0u;
        constexpr auto pixel_shader_max_dist_offset = 1u;
        constexpr auto pixel_shader_fog_starts_at_offset = 2u;

        const float cur_pos_constant[4] = {cam->look_at_target.x, cam->look_at_target.y, cam->look_at_target.z, 0.0f};
        if (device->SetPixelShaderConstantF(pixel_shader_cur_pos_offset, cur_pos_constant, 1) != D3D_OK) {
            Log::Error("GameWorldRenderer: unable to SetPixelShaderConstantF#0, aborting render.");
            return;
        }

        // second is the render max distance
        const float max_dist_constant[4] = {render_max_distance, 0.0f, 0.0f, 0.0f};
        if (device->SetPixelShaderConstantF(pixel_shader_max_dist_offset, max_dist_constant, 1) != D3D_OK) {
            Log::Error("GameWorldRenderer: unable to SetPixelShaderConstantF#1, aborting render.");
            return;
        }

        // third is the fog constant
        const float fog_starts_at_constant[4] = {render_max_distance - render_max_distance * fog_factor, 0.0f, 0.0f, 0.0f};
        if (device->SetPixelShaderConstantF(pixel_shader_fog_starts_at_offset, fog_starts_at_constant, 1) != D3D_OK) {
            Log::Error("GameWorldRenderer: unable to SetPixelShaderConstantF#2, aborting render.");
            return;
        }

        const auto map_id = GW::Map::GetMapID();
        renderables_mutex.lock();
        for (const auto& renderable : renderables) {
            if (renderable->map_id == map_id) {
                renderable->Draw(device);
            }
        }
        renderables_mutex.unlock();
    }

    // restore immediate state:
    device->SetRenderState(D3DRS_SCISSORTESTENABLE, old_D3DRS_SCISSORTESTENABLE);
    device->SetRenderState(D3DRS_STENCILENABLE, old_D3DRS_STENCILENABLE);
}

bool GameWorldRenderer::ConfigureProgrammablePipeline(IDirect3DDevice9* device)
{
    constexpr D3DVERTEXELEMENT9 decl[] = {{0, 0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_POSITION, 0}, {0, 12, D3DDECLTYPE_D3DCOLOR, D3DDECLMETHOD_DEFAULT, D3DDECLUSAGE_COLOR, 0}, D3DDECL_END()};
    if (device->CreateVertexDeclaration(decl, &vertex_declaration) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to CreateVertexDeclaration");
        return false;
    }

    if (device->CreateVertexShader(reinterpret_cast<const DWORD*>(&g_vs20_main), &vshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    if (device->CreatePixelShader(reinterpret_cast<const DWORD*>(&g_ps20_main), &pshader) != D3D_OK) {
        Log::Error("GameWorldRenderer: unable to CreateVertexShader");
        return false;
    }
    need_configure_pipeline = false;
    return true;
}

void GameWorldRenderer::LoadSettings(const ToolboxIni* ini, const char* section)
{
    // load the rendering settings from disk
    render_max_distance = std::max(static_cast<float>(ini->GetDoubleValue(section, VAR_NAME(render_max_distance), render_max_distance)), 10.0f);
    lerp_steps_per_line = ini->GetLongValue(section, VAR_NAME(lerp_steps_per_line), lerp_steps_per_line);
    fog_factor = std::clamp(static_cast<float>(ini->GetDoubleValue(section, VAR_NAME(fog_factor), fog_factor)), 0.0f, 1.0f);
    need_sync_markers = true;
}

void GameWorldRenderer::SaveSettings(ToolboxIni* ini, const char* section)
{
    // save the rendering settings to disk
    ini->SetDoubleValue(section, VAR_NAME(render_max_distance), render_max_distance);
    ini->SetLongValue(section, VAR_NAME(lerp_steps_per_line), lerp_steps_per_line);
    ini->SetDoubleValue(section, VAR_NAME(fog_factor), fog_factor);
}

void GameWorldRenderer::DrawSettings()
{
    // draw the settings using ImGui
    const auto red = ImGui::ColorConvertU32ToFloat4(Colors::Red());
    ImGui::TextColored(red, "Warning: This is a beta feature and will render over your character, game props, and UI elements.");
    ImGui::Text("Note: custom markers are only rendered in-game if the option is enabled for a particular marker (check settings).");
    ImGui::DragFloat("Maximum render distance", &render_max_distance, 5.f, 0.f, 10000.f, "%.0f", ImGuiSliderFlags_AlwaysClamp);
    ImGui::ShowHelp("Maximum distance to render custom markers on the in-game terrain.");
    need_sync_markers |= ImGui::DragInt("Interpolation granularity", reinterpret_cast<int*>(&lerp_steps_per_line), 1.0f, 0, 100, "%d", ImGuiSliderFlags_AlwaysClamp);
    ImGui::ShowHelp("Number of points to interpolate. Affects smoothness of rendering.");
    ImGui::DragFloat("Fog factor", &fog_factor, 0.1f, 0.0f, 1.0f, "%.2f", ImGuiSliderFlags_AlwaysClamp);
    ImGui::ShowHelp("Scales from 0.0 (disabled) to 1.0");
}

void GameWorldRenderer::TriggerSyncAllMarkers()
{
    // a publicly accessible function to trigger a re-sync of all custom markers
    need_sync_markers = true;
}

void GameWorldRenderer::Terminate()
{
    // free up any vertex buffers
    renderables.clear();
}

void GameWorldRenderer::SyncAllMarkers(IDirect3DDevice9* device)
{
    renderables_mutex.lock();
    renderables.clear();
    SyncLines(device);
    SyncPolys(device);
    SyncMarkers(device);
    renderables_mutex.unlock();
    need_sync_markers = false;
}

void GameWorldRenderer::SyncLines(IDirect3DDevice9* device)
{
    // sync lines with CustomRenderer
    const auto& lines = Minimap::Instance().custom_renderer.GetLines();
    // for each line, add as a renderable if appropriate
    for (const auto& line : lines) {
        if (!line.draw_on_terrain || !line.visible) {
            continue;
        }
        std::vector points = {line.p1, line.p2};
        renderables.push_back(std::make_unique<GenericPolyRenderable>(device, line.map, points, line.color, false));
    }
}

void GameWorldRenderer::SyncPolys(IDirect3DDevice9* device)
{
    // sync polygons with CustomRenderer
    const auto& polys = Minimap::Instance().custom_renderer.GetPolys();
    // for each poly, add as a renderable if appropriate
    for (const auto& poly : polys) {
        if (!poly.draw_on_terrain || !poly.visible) {
            continue;
        }
        if (poly.points.empty()) {
            continue;
        }
        renderables.push_back(std::make_unique<GenericPolyRenderable>(device, poly.map, poly.points, poly.color, poly.filled));
    }
}

void GameWorldRenderer::SyncMarkers(IDirect3DDevice9* device)
{
    // sync markers with CustomRenderer
    const auto& markers = Minimap::Instance().custom_renderer.GetMarkers();
    // for each marker, add as a renderable if appropriate
    for (const auto& marker : markers) {
        if (!marker.draw_on_terrain || !marker.visible) {
            continue;
        }
        std::vector<GW::Vec2f> points = circular_points_from_marker(marker.pos.x, marker.pos.y, marker.size);
        renderables.push_back(std::make_unique<GenericPolyRenderable>(device, marker.map, points, marker.color, marker.IsFilled()));
    }
}
